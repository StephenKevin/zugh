

from datetime import date, datetime
from decimal import Decimal

from .base import ExpBase
from .condition import ConditionBase


class LogicBase(ExpBase):
    """Logic class to deal with logic relation"""

    def __or__(self, term):
        """use `|` to act OR"""
        return OR(self, term)

    def __and__(self, term):
        """use `&` to act AND"""
        return AND(self, term)


class L(LogicBase):
    """Convert express to Logic object"""

    def __init__(self, *terms, **kw_terms):
        """Logic object"""
        if len(terms)+len(kw_terms) != 1:
            raise Exception(
                'param error: L class must receive at least one and only one parameter')
        if terms:
            if not isinstance(terms[0], str):
                raise Exception('only accept string')
            self._value = terms[0]
        else:
            k, v = kw_terms.popitem()
            k = k.replace('__', '.')
            if isinstance(v, ConditionBase):
                self._value = f'{k} {v}'
            elif isinstance(v, (str, Decimal, datetime, date)):
                self._value = f"{k} = '{v}'"
            else:
                self._value = f'{k} = {v}'

    def __eq__(self, item):
        return self._value == str(item)

    @property
    def get_str(self):
        return self._value

    def __repr__(self):
        return f'L({self})'


class ComplexLogicBase(LogicBase):

    def __init__(self, *terms, **kw_terms):
        self._terms = []
        for term in terms:
            self._add(term)

        for k, v in kw_terms.items():
            self._add(L(**{k: v}))

        self._value = f'({self.get_str})'

    def __iter__(self):
        return iter(self._terms)

    def __len__(self):
        return len(self._terms)

    def __getitem__(self, key):
        return self._terms[key]

    def _add(self, term):
        if term not in self:
            if isinstance(term, LogicBase):
                if isinstance(term, self.__class__):
                    for t in term:
                        self._terms.append(t)
                else:
                    self._terms.append(term)
            else:
                self._terms.append(L(term))

    @property
    def get_str(self):
        if len(self) == 1:
            return self[0].get_str
        else:
            term_list = [str(c) for c in self]
            op = f' {self.__class__.__name__} '
            v = op.join(term_list)
            return f'{v}'

    def __repr__(self):
        term_list = [repr(c) for c in self]
        v = ','.join(term_list)
        return f'{self.__class__.__name__}({v})'


class AND(ComplexLogicBase):
    """Logic AND"""


class OR(ComplexLogicBase):
    """Logic OR"""
